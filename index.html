<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Royale - Enhanced UI</title>
<style>
  :root {
    --blue: #3b82f6;
    --red: #ef4444;
    --gold: #ffd700;
    --bg: radial-gradient(circle at 50% 20%, #8cd3ff, #aee3ff 60%, #ccf3ff);
    --glass: rgba(255,255,255,0.25);
  }
  html, body {
    margin: 0;
    font-family: "Poppins", system-ui, sans-serif;
    background: var(--bg);
    color: #111;
    overflow-x: hidden;
  }
  #gameContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px;
    min-height: 100vh;
  }

  /* ---- CANVAS ---- */
  canvas {
    width: min(95vw, 960px);
    height: calc(min(95vw, 960px) * 9 / 16);
    border-radius: 16px;
    box-shadow: 0 12px 40px rgba(0,0,0,.25);
    background: linear-gradient(#cdeeff, #e9f9ff);
    cursor: crosshair;
  }

  /* ---- STATUS BAR ---- */
  #topHud {
    position: relative;
    margin-top: 12px;
    width: min(95vw, 960px);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--glass);
    backdrop-filter: blur(8px);
    border-radius: 12px;
    padding: 8px 18px;
    color: #000;
    font-weight: 600;
    box-shadow: 0 2px 12px rgba(0,0,0,0.1);
  }
  .crownBox {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .crownBox span {
    font-size: 1.1em;
  }
  .crown {
    color: var(--gold);
    text-shadow: 0 0 5px #ff0;
  }

  #timer {
    font-size: 1.2em;
    font-weight: 700;
    letter-spacing: 1px;
  }

  /* ---- ELIXIR BAR ---- */
  #elixirPanel {
    position: relative;
    margin-top: 12px;
    width: min(95vw, 960px);
    background: var(--glass);
    border-radius: 12px;
    padding: 10px 18px;
    backdrop-filter: blur(6px);
    box-shadow: 0 2px 12px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .elixirBar {
    position: relative;
    width: 220px;
    height: 18px;
    background: #ffffff40;
    border-radius: 10px;
    overflow: hidden;
  }
  .elixirFill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #b0f0ff, #5fc8ff);
    border-radius: 10px;
    transition: width 0.25s;
    box-shadow: 0 0 8px #6bdcff;
  }

  /* ---- CARDS ---- */
  #cardDock {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-top: 14px;
    flex-wrap: wrap;
    width: min(95vw, 960px);
  }
  .card {
    width: 72px;
    height: 96px;
    background: rgba(255,255,255,0.4);
    border-radius: 10px;
    border: 2px solid rgba(255,255,255,0.7);
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-weight: 600;
    transition: transform 0.2s, box-shadow 0.2s;
    cursor: pointer;
    backdrop-filter: blur(4px);
  }
  .card:hover {
    transform: translateY(-4px);
    box-shadow: 0 6px 14px rgba(0,0,0,0.25);
  }
  .card.active {
    outline: 3px solid var(--blue);
    box-shadow: 0 0 14px #3b82f6aa;
  }
  .cost {
    background: var(--blue);
    color: white;
    border-radius: 50%;
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8em;
    position: absolute;
    bottom: 6px;
    right: 6px;
  }

  /* ---- TOAST ---- */
  #toast {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.75);
    color: white;
    padding: 8px 14px;
    border-radius: 6px;
    font-size: 0.9em;
    opacity: 0;
    transition: opacity 0.4s;
  }

  #restart {
    margin-top: 14px;
    padding: 8px 16px;
    background: var(--blue);
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(59,130,246,0.4);
    transition: transform 0.2s;
  }
  #restart:hover {
    transform: scale(1.05);
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="canvas" width="960" height="540"></canvas>
  <div id="toast"></div>

  <div id="topHud">
    <div class="crownBox">
      <span class="crown">ðŸ‘‘</span> <span id="playerCrowns">0</span>
    </div>
    <div id="timer">02:00</div>
    <div class="crownBox">
      <span id="opponentCrowns">0</span> <span class="crown">ðŸ‘‘</span>
    </div>
  </div>

  <div id="elixirPanel">
    <div class="elixirBar"><div class="elixirFill" id="elixirFill"></div></div>
    <div id="elixirCount">5</div>
  </div>

  <div id="cardDock"></div>

  <button id="restart">Restart Match</button>
</div>

<script>
// --- GAME LOGIC (simplified from previous version, focus on visuals) ---
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;

const CARD_DEFS = {
  knight: {cost:3,hp:120,atk:25,range:20,speed:40,type:'melee',color:'#7b3'},
  archer: {cost:3,hp:70,atk:18,range:120,speed:55,type:'ranged',color:'#39f',attackCooldown:1.2},
  bomber: {cost:4,hp:80,atk:55,range:20,speed:36,type:'splash',radius:45,color:'#f59'},
  fireball: {cost:4,type:'spell',radius:50,damage:80,color:'#ff8a65'}
};

let state;
function init(){
  state = {
    running:true,timeLeft:120,
    player:{elixir:5,crowns:0},
    opponent:{elixir:5,crowns:0},
    units:[],towers:[],projectiles:[],
    selected:null,toast:0,last:performance.now()
  };
  const tHP=400;
  [
    {x:220,y:420,side:'player'},{x:480,y:380,side:'player',king:true},{x:740,y:420,side:'player'},
    {x:220,y:120,side:'opponent'},{x:480,y:160,side:'opponent',king:true},{x:740,y:120,side:'opponent'}
  ].forEach(p=>{
    state.towers.push({x:p.x,y:p.y,hp:p.king?tHP*1.5:tHP,side:p.side,king:p.king,range:140,atk:20,atkTimer:0});
  });
  setupUI();
}
function setupUI(){
  const dock=document.getElementById("cardDock");
  dock.innerHTML="";
  Object.keys(CARD_DEFS).forEach(id=>{
    const card=document.createElement("div");
    card.className="card";
    card.innerHTML=`<div>${id}</div><div class="cost">${CARD_DEFS[id].cost}</div>`;
    card.onclick=()=>{
      state.selected = (state.selected===id)?null:id;
      document.querySelectorAll(".card").forEach(c=>c.classList.remove("active"));
      if(state.selected) card.classList.add("active");
    };
    dock.appendChild(card);
  });
}
canvas.addEventListener("click",e=>{
  if(!state.selected) return;
  const rect=canvas.getBoundingClientRect();
  const x=(e.clientX-rect.left)*canvas.width/rect.width;
  const y=(e.clientY-rect.top)*canvas.height/rect.height;
  if(y<H/2){showToast("Place on your side only");return;}
  const def=CARD_DEFS[state.selected];
  if(state.player.elixir<def.cost){showToast("Not enough elixir");return;}
  if(def.type==="spell"){
    state.projectiles.push({x,y,r:def.radius,damage:def.damage,life:0.5,owner:'player',color:def.color});
  }else{
    state.units.push({x,y,hp:def.hp,atk:def.atk,range:def.range,speed:def.speed,side:'player',color:def.color,atkTimer:0,cd:def.attackCooldown||1});
  }
  state.player.elixir-=def.cost;
  state.selected=null;
  document.querySelectorAll(".card").forEach(c=>c.classList.remove("active"));
});

function showToast(msg){
  const toast=document.getElementById("toast");
  toast.textContent=msg;
  toast.style.opacity=1;
  clearTimeout(toast._hide);
  toast._hide=setTimeout(()=>toast.style.opacity=0,1500);
}

function tick(dt){
  if(!state.running) return;
  state.timeLeft-=dt;
  state.player.elixir=Math.min(10,state.player.elixir+dt*0.7);
  state.opponent.elixir=Math.min(10,state.opponent.elixir+dt*0.7);

  // AI simple spawn
  if(!state.ai) state.ai={t:0};
  state.ai.t-=dt;
  if(state.ai.t<=0){
    const ids=Object.keys(CARD_DEFS);
    const id=ids[Math.floor(Math.random()*ids.length)];
    const def=CARD_DEFS[id];
    if(def.cost<=state.opponent.elixir){
      state.opponent.elixir-=def.cost;
      if(def.type==='spell'){
        const tx=220+Math.random()*500,ty=350+Math.random()*80;
        state.projectiles.push({x:tx,y:ty,r:def.radius,damage:def.damage,life:0.5,owner:'opponent',color:def.color});
      }else{
        const x=120+Math.random()*(W-240),y=80+Math.random()*60;
        state.units.push({x,y,hp:def.hp,atk:def.atk,range:def.range,speed:def.speed,side:'opponent',color:def.color,atkTimer:0,cd:def.attackCooldown||1});
      }
    }
    state.ai.t=1+Math.random()*1.5;
  }

  // simple combat
  state.units.forEach(u=>{
    u.atkTimer-=dt;
    const enemies=state.units.filter(e=>e.side!==u.side);
    let t=enemies[0];
    if(t){
      const dx=t.x-u.x,dy=t.y-u.y,d=Math.hypot(dx,dy);
      if(d<(u.range||20)){
        if(u.atkTimer<=0){t.hp-=u.atk;u.atkTimer=u.cd;}
      }else{
        u.x+=dx/d*u.speed*dt*(u.side==='player'?1:-1);
        u.y+=dy/d*u.speed*dt*(u.side==='player'?1:-1);
      }
    }
  });
  state.units=state.units.filter(u=>u.hp>0);

  // spells
  state.projectiles.forEach(p=>{
    p.life-=dt;
    if(p.life<=0){
      state.units.forEach(u=>{
        if(u.side!==(p.owner) && Math.hypot(u.x-p.x,u.y-p.y)<p.r) u.hp-=p.damage;
      });
    }
  });
  state.projectiles=state.projectiles.filter(p=>p.life>0);
  updateUI();
}

function updateUI(){
  document.getElementById("elixirFill").style.width=`${(state.player.elixir/10)*100}%`;
  document.getElementById("elixirCount").textContent=Math.floor(state.player.elixir);
  document.getElementById("playerCrowns").textContent=state.player.crowns;
  document.getElementById("opponentCrowns").textContent=state.opponent.crowns;
  const m=Math.floor(state.timeLeft/60),s=Math.floor(state.timeLeft%60);
  document.getElementById("timer").textContent=`${m}:${s.toString().padStart(2,'0')}`;
}

function render(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="#b5eaff";
  ctx.fillRect(0,H*0.25-10,W,H*0.5+20);
  ctx.strokeStyle="#ffffff99";
  ctx.beginPath();ctx.moveTo(0,H/2);ctx.lineTo(W,H/2);ctx.stroke();

  // towers
  state.towers.forEach(t=>{
    ctx.fillStyle=t.side==='player'? 'rgba(59,130,246,0.9)':'rgba(239,68,68,0.9)';
    ctx.fillRect(t.x-20,t.y-20,40,40);
    if(t.king){ctx.fillStyle='#ffd700';ctx.beginPath();ctx.moveTo(t.x-8,t.y-20);ctx.lineTo(t.x,t.y-30);ctx.lineTo(t.x+8,t.y-20);ctx.fill();}
  });

  // units
  state.units.forEach(u=>{
    ctx.fillStyle=u.color;
    ctx.beginPath();ctx.arc(u.x,u.y,10,0,Math.PI*2);ctx.fill();
  });

  // projectiles
  state.projectiles.forEach(p=>{
    ctx.globalAlpha=Math.max(0.3,p.life/0.5);
    ctx.fillStyle=p.color;
    ctx.beginPath();ctx.arc(p.x,p.y,p.r,0,Math.PI*2);ctx.fill();
    ctx.globalAlpha=1;
  });
}

function loop(t){
  const dt=Math.min(0.05,(t-state.last)/1000);
  state.last=t;
  tick(dt);render();
  requestAnimationFrame(loop);
}

document.getElementById("restart").onclick=()=>init();
init();
requestAnimationFrame(loop);
</script>
</body>
</html>
